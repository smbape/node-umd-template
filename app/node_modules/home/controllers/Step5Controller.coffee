deps = [
    'umd-core/src/common'
    'umd-core/src/ClientController'
    'umd-core/src/models/BackboneCollection'
    'umd-core/src/validation/validators'
    'umd-core/src/views/ReactModelView'
    'umd-core/src/views/ReactCollectionView'
    'umd-core/src/components/AbstractModelComponent'
    'umd-core/src/components/InputText'
    'umd-core/src/components/InputWithError'
    '../test/mock' # Simulate ajax calls to /rest/users
]

freact = (
    { _, $, Backbone, i18n }
    ClientController
    BackboneCollection
    validators
    ReactModelView
    ReactCollectionView
    AbstractModelComponent
    InputText
    InputWithError
)->

    btnRaisedRipple = 'mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect'
    btnAccent = btnRaisedRipple + ' mdl-button--accent'
    btnDanger = btnRaisedRipple + ' btn-danger'
    btnCancel = btnRaisedRipple + ' mdl-button--colored'

    # ================================================================
    # /!\ Note
    # ================================================================
    # Models may be used by multiple views and/or controllers.
    # Views may be used by multiple controllers.
    # 
    # For that reason, it is a good idea to put each Model and View in its own file.
    # However, for the simplicity of this tutorial, we will not do that.

    class User extends Backbone.Model
        # http://backbonejs.org/#Model-urlRoot
        # GET    "[urlRoot]/id" to read values of a model
        # PUT    "[urlRoot]/id" to update values of a model
        # PATCH  "[urlRoot]/id" to patch values of a model
        # DELETE "[urlRoot]/id" to delete a model
        urlRoot: '/rest/users'

        validation: lastName: validators.required()

    class UserList extends BackboneCollection
        # http://backbonejs.org/#Model-url
        # GET    "[collection.url]"    to read all values of a collection
        # GET    "[collection.url]/id" to read values of a model
        # PUT    "[collection.url]/id" to update values of a model
        # PATCH  "[collection.url]/id" to patch values of a model
        # DELETE "[collection.url]/id" to delete a model
        url: '/rest/users'

        # http://backbonejs.org/#Collection-model
        model: User

    # Any view used by a controller will have the controller in this.props.controller
    class UserListView extends ReactModelView

        deleteUser: (user)->
            if @xhr
                @xhr.abort()
                @xhr = null
            @xhr = user.destroy complete: @onComplete
            return

        onComplete: =>
            @xhr = null
            return

        componentWillUnmount: ->
            if @xhr
                @xhr.abort()
                @xhr = null
            super
            return

        # note the '=>' instead of '->'
        childNode: (user, index)=>
            `<tr className="user" key={ index }>
                <td>{ user.get("firstName") }</td>
                <td>{ user.get("lastName") }</td>
                <td>{ user.get("age") }</td>
                <td>
                    { /* We use a clone of user model to only update data on save, not on cancel */ }
                    <ModalEditView
                        href={ this.props.getEditUrl(user) }
                        model={ user.clone() }
                        onSave={ this.props.onSave }
                        onDelete={ this.props.onDelete }
                        onCancel={ this.props.onCancel } />

                    &nbsp;&nbsp;
                    <button spClick={ this.deleteUser(user) } type="button" className={ 'delete-user ' + btnDanger }>
                        { i18n.t('button.delete') }
                    </button>
                </td>
            </tr>`

        render: ->
            `<div>
                <ModalEditView
                    href={ this.props.getEditUrl() }
                    model={ new User() }
                    onSave={ this.props.onSave }
                    onDelete={ this.props.onDelete }
                    onCancel={ this.props.onCancel } />
                <br/>
                <br/>

                <table className="table striped" style={ { tableLayout: 'fixed' } }>
                    <thead>
                        <tr>
                            <th>{ i18n.t('label.firstName') }</th>
                            <th>{ i18n.t('label.lastName') }</th>
                            <th>{ i18n.t('label.age') }</th>
                            <th />
                        </tr>
                    </thead>
                    <ReactCollectionView
                        tagName="tbody"
                        className="users"
                        model={ this.props.model }
                        childNode={ this.childNode }
                    />
                </table>
            </div>`

    class EditView extends ReactModelView
        onSave: =>
            if @props.onSave
                @props.onSave.apply @props, arguments
            return

        onDelete: =>
            if @props.onDelete
                @props.onDelete.apply @props, arguments
            return

        onCancel: =>
            if @props.onCancel
                @props.onCancel.apply @props, arguments
            return

        onComplete: =>
            @xhr = null
            return

        saveUser: (evt)=>
            evt.preventDefault()
            if @xhr
                @xhr.abort()
                @xhr = null

            user = @props.model
            invalidAttrs = user.validate null, { forceUpdate: false }
            if not invalidAttrs
                @xhr = user.save null,
                    success: @onSave
                    complete: @onComplete
            return

        deleteUser: (evt)=>
            evt.preventDefault()
            if @xhr
                @xhr.abort()
                @xhr = null
            @props.model.destroy
                success: @onSave
                complete: @onComplete
            return

        componentWillUnmount: ->
            if @xhr
                @xhr.abort()
                @xhr = null
            super
            return

        getTitle: ->
            i18n.t('label.user.' + (if @props.model.id then 'edit' else 'create'))

        getFieldSet: ->
            user = @props.model
            `<span className="fieldset">
                <InputText spModel={ user.firstName } label={ i18n.t('label.firstName') } />
                <InputWithError spModel={ user.lastName } label={ i18n.t('label.lastName') } />
                <InputText spModel={ user.age } label={ i18n.t('label.age') } />
            </span>`

        getButtons: ->
            `<span className="buttons">
                <button spShow={ this.props.model.id } onClick={ this.deleteUser } type="button" className={ btnDanger }>
                    { i18n.t('button.delete') }
                </button>
                &nbsp;&nbsp;
                <button type="button" onClick={ this.onCancel } className={ btnCancel }>
                    { i18n.t('button.cancel') }
                </button>
                &nbsp;&nbsp;
                <button type="submit" className={ btnAccent }>
                    { i18n.t('button.save') }
                </button>
            </span>`

        render: ->
            `<form onSubmit={ this.saveUser } className="container">
                <h4>{ this.getTitle() }</h4>

                { this.getFieldSet() }

                { this.getButtons() }
            </form>`

    class ModalEditView extends EditView
        showModal: (pevt)=>
            evt = pevt.nativeEvent

            # Only open popin on left click with no fancy stuff
            # allowing open in new tab|window shortcut
            which = evt.which
            return if which isnt 1 or evt.altKey or evt.ctrlKey or evt.shiftKey

            pevt.preventDefault()
            @refs.dialog.showModal()
            return

        onSave: =>
            @refs.dialog.close()
            super
            return

        onDelete: =>
            @refs.dialog.close()
            super
            return

        onCancel: =>
            @refs.dialog.close()
            return

        render: ->
            `<span>
                {/*
                    React listen click event on DOM,
                    however, the navigate callback on a[href] is before the React callback.
                    For that reason, there is a class name to bypass navigate callback on a[href]
                */}
                <a href={ this.props.href } type="button" className={ 'no-navigate ' + btnAccent } onClick={ this.showModal }>
                    { i18n.t(this.props.model.id ? 'button.edit' : 'label.user.create') }
                </a>
                <Dialog ref="dialog" className="modal">
                    <form onSubmit={ this.saveUser }>
                        <div className="mdl-dialog__title">{ this.getTitle() }</div>
                        <div className="mdl-dialog__content">{ this.getFieldSet() }</div>
                        <div className="mdl-dialog__actions">{ this.getButtons() }</div>
                    </form>
                </Dialog>
            </span>`

    class Step5Controller extends ClientController
        getEditUrl: (user)=>
            @getUrl({
                action: 'edit-user'
                id: user and user.id or null
            }, {
                query: redirect: @get('router').getCurrentUrl()
            })

        onSave: =>
            if redirect = @get('queryParams').redirect
                @navigate redirect, { force: true }
            else
                @get('router').refresh()
            return

        onDelete: =>
            if redirect = @get('queryParams').redirect
                @navigate redirect, { force: true }
            else
                @get('router').refresh()
            return

        onCancel: =>
            if redirect = @get('queryParams').redirect
                @navigate redirect, { force: true }
            else
                @get('router').refresh()
            return

        listUserAction: (done)->
            list = new UserList()
            @render UserListView, {
                model: list
                getEditUrl: @getEditUrl
                onSave: @onSave
                onDelete: @onDelete
                onCancel: @onCancel
            }, done
            list.fetch()
            return

        editUserAction: (done)->
            user = new User id: @get('pathParams').id
            render = @render.bind @, EditView, {
                model: user
                onSave: @onSave
                onDelete: @onDelete
                onCancel: @onCancel
            }, done

            if user.id
                user.fetch complete: render
            else
                render()

            return
